import { constant, isFunction } from 'lodash';
import { guid } from 'helpers/misc';
import { getConfig } from '../../modules/config';
import { selectOAuthToken, selectSessionToken } from '../../modules/auth';
import { getExtraHeaders } from '../../modules';
import fetchGraphQLApi from './fetchGraphQLApi';

async function callGraphQLApi({
  actionTypes: [requestType, successType, failureType],
  extraHeaders,
  query,
  variables,
  operationName,
  bailout = constant(false),
  dispatch,
  getState,
  // optional requestId which can be given to the selectors generated by
  // handleApiCall to track state of an individual request (by default only the
  // latest request is tracked)
  requestId
}) {
  if (!isFunction(dispatch) || !isFunction(getState)) {
    throw new Error('callGraphQLApi requires dispatch and getState functions');
  }

  const state = getState();
  const config = getConfig(state);
  const endpoint = `${config.apiRoot}/${config.graphQLEndpoint}`;
  const token = selectOAuthToken(state) || selectSessionToken(state);

  const shouldBail = bailout(state);
  if (shouldBail) {
    return;
  }

  let _extraHeaders = extraHeaders;
  if (!Object.keys(extraHeaders || {}).length) {
    _extraHeaders = getExtraHeaders(state);
  }

  // attach an ID so the handleApiCall reducer can track this request across
  // its multiple actions
  const _internalRequestId = requestId || guid();

  dispatch({
    type: requestType,
    meta: {
      variables,
      operationName,
      query,
      _internalRequestId,
      _shouldTrackRequestsIndividually: !!requestId
    }
  });

  let response;
  try {
    response = await fetchGraphQLApi({
      endpoint,
      query,
      variables,
      operationName,
      token,
      extraHeaders: _extraHeaders
    });
  } catch (e) {
    dispatch({
      type: failureType,
      error: true,
      payload: e,
      meta: {
        response,
        variables,
        operationName,
        query,
        _internalRequestId,
        _shouldTrackRequestsIndividually: !!requestId
      }
    });

    let error = new Error('API call failed');
    // wrap this single error for consistency with graphQL errors, which are always
    // wrapped.
    error.errors = [e];
    throw error;
  }

  if (response.errors && response.errors.length) {
    dispatch({
      type: failureType,
      error: true,
      payload: response.errors,
      meta: {
        response,
        variables,
        operationName,
        query,
        _internalRequestId,
        _shouldTrackRequestsIndividually: !!requestId
      }
    });

    let error = new Error('API response included errors');
    error.errors = response.errors;
    throw error;
  }

  dispatch({
    type: successType,
    payload: response.data,
    meta: {
      response,
      variables,
      operationName,
      query,
      _internalRequestId,
      _shouldTrackRequestsIndividually: !!requestId
    }
  });

  return response.data;
}

export default callGraphQLApi;
